«Жадібні» алгоритми
US coins

Коли ви даєте решту, то, мабуть, хочете мінімізувати кількість монеток для кожного покупця, бо вони можуть закінчитись, 
а покупці – розлютитись! На щастя, комп'ютерні науки надали можливість касирам по всьому світу мінімізувати кількість монеток: 
вони винайшли «жадібні» алгоритми.

Відповідно до National Institute of Standards and Technology (NIST), жадібний алгоритм - це такий алгоритм, який «завжди обирає 
найкращий миттєвий, чи локальний, розв'язок під час пошуку відповіді. Жадібні алгоритми знаходять глобальний оптимальний розв'язок
 для деяких задач, але можуть знайти неоптимальний розв'язок для деяких інших задач».

Що все це означає? Припустимо, що касир має видати клієнту решту, і в нього є пристрій, що видає монети у 25, 10, 5 та 1 центи. 
Для того, щоб розв'язати цю «задачу», касирові потрібно один чи декілька разів натиснути на важелі. 
«Жадібний» касир із кожним натисканням захоче забрати із потрібної суми максимально можливий обсяг. 
Наприклад, якщо він винний якомусь клієнтові 41 цент, найбільший (тобто локально-оптимальний) обсяг цієї суми, 
який можна покрити одним натисканням - це 25 центів (ця сума є «найкращою», тому що вона приводить нас ближче до суми 0 центів швидше, 
ніж всі інші монетки). Помітимо, що після цієї дії нам тепер потрібно видати не 41 цент, а 16 центів (41 - 25 = 16). 
А отже, видання такого обсягу здачі - це схожа, але менша за попередню задача. Зрозуміло, що видати ще 25 центів ми не можемо 
(ця сума буде занадто великою - касир не хоче втрачати гроші!), а, отже, наш жадібний касир візьме монетку розміром 10 центів, що 
залишить його із рештою видачі на 6 центів. На цьому етапі, жадібність змусить касира видати 5 центів, а потім 1 цент, і після цього задача буде розв'язана. 
Клієнт отримає по одній монетці на 25, 10, 5 та 1 центи: 4 монетки загалом.

Виявляється, що такий жадібний підхід (тобто алгоритм) є не тільки локально-оптимальним, але і глобально-оптимальним для американських монеток 
(а також для монеток Європейського Союзу). Тобто, якщо припустити, що у касира достатньо монеток, цей підхід «від більшого до меншого» приведе 
до найменшої кількості виданих монеток. Скільки саме монеток буде видано для довільної задачі? Що ж, дізнатись це і є вашою задачею!


Напишіть програму cash.js, яка питатиме у користувача, скільки решти необхідно видати, а потім видає мінімальну кількість монеток, за допомогою яких цей обсяг 
решти можна видати.
припускайте, що на вхід вашій програмі поступить величина 9.75 а не $9.75 чи 975. Якщо певному клієнтові винні 9 доларів рівно, 
припускайте, що на вхід вашій програмі поступить величина 9.00 чи 9, але, знову ж таки, не $9 або 900.

Ваша програма має поводитись, як у прикладах нижче.
Запитуйте через prompt скільки решти необхідно видати (Change owed)
Якщо користувач ввів 0.41 поверніть через alert кількість монеок 4

Change owed: 0.41
4

Якщо користувач вводить не валідне значення решти овідомлення prompt змінюється (Invalid valuie! Change owed:) поки користувач не введе валідне значення



Change owed: -0.41

Invalid valuie! Change owed: foo

Invalid valuie! Change owed: 0

Invalid valuie! Change owed: 0.41

alert Change is 4 coins - 25, 10, 5, 1

Change owed: 4.45

alert Change is 3 coins - 25, 10, 10




Як протестувати ваш код
Переконайтеся, що ваш код працює так, як описано, коли ви вводите:

-1.00 (або інше від’ємне число)?
0.00?
0.01 (або інше додатне число)?
літери або слова?
нічого не вводите, а просто натискаєте Enter?
після натиснення "скасувати" вікно закривається. 